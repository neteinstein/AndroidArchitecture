<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="pt">
<head>
<!-- Generated by javadoc (version 1.7.0_65) on Tue Sep 09 13:32:43 WEST 2014 -->
<title>ContextCompat</title>
<meta name="date" content="2014-09-09">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ContextCompat";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../android/support/v4/content/AsyncTaskLoader.html" title="class in android.support.v4.content"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../android/support/v4/content/CursorLoader.html" title="class in android.support.v4.content"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?android/support/v4/content/ContextCompat.html" target="_top">Frames</a></li>
<li><a href="ContextCompat.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">android.support.v4.content</div>
<h2 title="Class ContextCompat" class="title">Class ContextCompat</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>android.support.v4.content.ContextCompat</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../../android/support/v4/app/ActivityCompat.html" title="class in android.support.v4.app">ActivityCompat</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">ContextCompat</span>
extends java.lang.Object</pre>
<div class="block">Helper for accessing features in <code>android.content.Context</code>
 introduced after API level 4 in a backwards compatible fashion.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#ContextCompat()">ContextCompat</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.io.File[]</code></td>
<td class="colLast"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#getExternalCacheDirs(Context)">getExternalCacheDirs</a></strong>(Context&nbsp;context)</code>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application can place cache files it
 owns.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.io.File[]</code></td>
<td class="colLast"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#getExternalFilesDirs(Context,%20java.lang.String)">getExternalFilesDirs</a></strong>(Context&nbsp;context,
                    java.lang.String&nbsp;type)</code>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application can place persistent files
 it owns.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.io.File[]</code></td>
<td class="colLast"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#getObbDirs(Context)">getObbDirs</a></strong>(Context&nbsp;context)</code>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application's OBB files (if there are
 any) can be found.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#startActivities(Context,%20Intent[])">startActivities</a></strong>(Context&nbsp;context,
               Intent[]&nbsp;intents)</code>
<div class="block">Start a set of activities as a synthesized task stack, if able.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../android/support/v4/content/ContextCompat.html#startActivities(Context,%20Intent[],%20Bundle)">startActivities</a></strong>(Context&nbsp;context,
               Intent[]&nbsp;intents,
               Bundle&nbsp;options)</code>
<div class="block">Start a set of activities as a synthesized task stack, if able.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="ContextCompat()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ContextCompat</h4>
<pre>public&nbsp;ContextCompat()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="startActivities(Context, Intent[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivities</h4>
<pre>public static&nbsp;boolean&nbsp;startActivities(Context&nbsp;context,
                      Intent[]&nbsp;intents)</pre>
<div class="block">Start a set of activities as a synthesized task stack, if able.

 <p>In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the "recents" UI, accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key.</p>

 <p>When crossing from one task stack to another post-Android 3.0,
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks.</p>

 <p>startActivities provides a mechanism for constructing a synthetic task stack of
 multiple activities. If the underlying API is not available on the system this method
 will return false.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>context</code> - Start activities using this activity as the starting context</dd><dd><code>intents</code> - Array of intents defining the activities that will be started. The element
                length-1 will correspond to the top activity on the resulting task stack.</dd>
<dt><span class="strong">Returns:</span></dt><dd>true if the underlying API was available and the call was successful, false otherwise</dd></dl>
</li>
</ul>
<a name="startActivities(Context, Intent[], Bundle)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startActivities</h4>
<pre>public static&nbsp;boolean&nbsp;startActivities(Context&nbsp;context,
                      Intent[]&nbsp;intents,
                      Bundle&nbsp;options)</pre>
<div class="block">Start a set of activities as a synthesized task stack, if able.

 <p>In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
 app navigation using the back key changed. The back key's behavior is local
 to the current task and does not capture navigation across different tasks.
 Navigating across tasks and easily reaching the previous task is accomplished
 through the "recents" UI, accessible through the software-provided Recents key
 on the navigation or system bar. On devices with the older hardware button configuration
 the recents UI can be accessed with a long press on the Home key.</p>

 <p>When crossing from one task stack to another post-Android 3.0,
 the application should synthesize a back stack/history for the new task so that
 the user may navigate out of the new task and back to the Launcher by repeated
 presses of the back key. Back key presses should not navigate across task stacks.</p>

 <p>startActivities provides a mechanism for constructing a synthetic task stack of
 multiple activities. If the underlying API is not available on the system this method
 will return false.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>context</code> - Start activities using this activity as the starting context</dd><dd><code>intents</code> - Array of intents defining the activities that will be started. The element
                length-1 will correspond to the top activity on the resulting task stack.</dd><dd><code>options</code> - Additional options for how the Activity should be started.
 See {@link android.content.Context#startActivity(Intent, Bundle)</dd>
<dt><span class="strong">Returns:</span></dt><dd>true if the underlying API was available and the call was successful, false otherwise</dd></dl>
</li>
</ul>
<a name="getObbDirs(Context)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObbDirs</h4>
<pre>public static&nbsp;java.io.File[]&nbsp;getObbDirs(Context&nbsp;context)</pre>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application's OBB files (if there are
 any) can be found. Note if the application does not have any OBB files,
 these directories may not exist.
 <p>
 This is like <code>Context#getFilesDir()</code> in that these files will be
 deleted when the application is uninstalled, however there are some
 important differences:
 <ul>
 <li>External files are not always available: they will disappear if the
 user mounts the external storage on a computer or removes it.
 <li>There is no security enforced with these files.
 </ul>
 <p>
 External storage devices returned here are considered a permanent part of
 the device, including both emulated external storage and physical media
 slots, such as SD cards in a battery compartment. The returned paths do
 not include transient devices, such as USB flash drives.
 <p>
 An application may store data on any or all of the returned devices. For
 example, an app may choose to store large files on the device with the
 most available space, as measured by <code>StatFs</code>.
 <p>
 Starting in <code>android.os.Build.VERSION_CODES#KITKAT</code>, no permissions
 are required to write to the returned paths; they're always accessible to
 the calling app. Before then,
 <code>android.Manifest.permission#WRITE_EXTERNAL_STORAGE</code> is required to
 write. Write access outside of these paths on secondary external storage
 devices is not available. To request external storage access in a
 backwards compatible way, consider using <code>android:maxSdkVersion</code>
 like this:

 <pre class="prettyprint">&lt;uses-permission
     android:name="android.permission.WRITE_EXTERNAL_STORAGE"
     android:maxSdkVersion="18" /&gt;</pre>
 <p>
 The first path returned is the same as <code>Context#getObbDir()</code>.
 Returned paths may be <code>null</code> if a storage device is unavailable.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>Context#getObbDir()</code>, 
<a href="../../../../android/support/v4/os/EnvironmentCompat.html#getStorageState(java.io.File)"><code>EnvironmentCompat.getStorageState(File)</code></a></dd></dl>
</li>
</ul>
<a name="getExternalFilesDirs(Context, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExternalFilesDirs</h4>
<pre>public static&nbsp;java.io.File[]&nbsp;getExternalFilesDirs(Context&nbsp;context,
                                  java.lang.String&nbsp;type)</pre>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application can place persistent files
 it owns. These files are internal to the application, and not typically
 visible to the user as media.
 <p>
 This is like <code>Context#getFilesDir()</code> in that these files will be
 deleted when the application is uninstalled, however there are some
 important differences:
 <ul>
 <li>External files are not always available: they will disappear if the
 user mounts the external storage on a computer or removes it.
 <li>There is no security enforced with these files.
 </ul>
 <p>
 External storage devices returned here are considered a permanent part of
 the device, including both emulated external storage and physical media
 slots, such as SD cards in a battery compartment. The returned paths do
 not include transient devices, such as USB flash drives.
 <p>
 An application may store data on any or all of the returned devices. For
 example, an app may choose to store large files on the device with the
 most available space, as measured by <code>StatFs</code>.
 <p>
 Starting in <code>android.os.Build.VERSION_CODES#KITKAT</code>, no permissions
 are required to write to the returned paths; they're always accessible to
 the calling app. Before then,
 <code>android.Manifest.permission#WRITE_EXTERNAL_STORAGE</code> is required to
 write. Write access outside of these paths on secondary external storage
 devices is not available. To request external storage access in a
 backwards compatible way, consider using <code>android:maxSdkVersion</code>
 like this:

 <pre class="prettyprint">&lt;uses-permission
     android:name="android.permission.WRITE_EXTERNAL_STORAGE"
     android:maxSdkVersion="18" /&gt;</pre>
 <p>
 The first path returned is the same as
 <code>Context#getExternalFilesDir(String)</code>. Returned paths may be
 <code>null</code> if a storage device is unavailable.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>Context#getExternalFilesDir(String)</code>, 
<a href="../../../../android/support/v4/os/EnvironmentCompat.html#getStorageState(java.io.File)"><code>EnvironmentCompat.getStorageState(File)</code></a></dd></dl>
</li>
</ul>
<a name="getExternalCacheDirs(Context)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>getExternalCacheDirs</h4>
<pre>public static&nbsp;java.io.File[]&nbsp;getExternalCacheDirs(Context&nbsp;context)</pre>
<div class="block">Returns absolute paths to application-specific directories on all
 external storage devices where the application can place cache files it
 owns. These files are internal to the application, and not typically
 visible to the user as media.
 <p>
 This is like <code>Context#getCacheDir()</code> in that these files will be
 deleted when the application is uninstalled, however there are some
 important differences:
 <ul>
 <li>External files are not always available: they will disappear if the
 user mounts the external storage on a computer or removes it.
 <li>There is no security enforced with these files.
 </ul>
 <p>
 External storage devices returned here are considered a permanent part of
 the device, including both emulated external storage and physical media
 slots, such as SD cards in a battery compartment. The returned paths do
 not include transient devices, such as USB flash drives.
 <p>
 An application may store data on any or all of the returned devices. For
 example, an app may choose to store large files on the device with the
 most available space, as measured by <code>StatFs</code>.
 <p>
 Starting in <code>android.os.Build.VERSION_CODES#KITKAT</code>, no permissions
 are required to write to the returned paths; they're always accessible to
 the calling app. Before then,
 <code>android.Manifest.permission#WRITE_EXTERNAL_STORAGE</code> is required to
 write. Write access outside of these paths on secondary external storage
 devices is not available. To request external storage access in a
 backwards compatible way, consider using <code>android:maxSdkVersion</code>
 like this:

 <pre class="prettyprint">&lt;uses-permission
     android:name="android.permission.WRITE_EXTERNAL_STORAGE"
     android:maxSdkVersion="18" /&gt;</pre>
 <p>
 The first path returned is the same as
 <code>Context#getExternalCacheDir()</code>. Returned paths may be <code>null</code>
 if a storage device is unavailable.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>Context#getExternalCacheDir()</code>, 
<a href="../../../../android/support/v4/os/EnvironmentCompat.html#getStorageState(java.io.File)"><code>EnvironmentCompat.getStorageState(File)</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../android/support/v4/content/AsyncTaskLoader.html" title="class in android.support.v4.content"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../android/support/v4/content/CursorLoader.html" title="class in android.support.v4.content"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?android/support/v4/content/ContextCompat.html" target="_top">Frames</a></li>
<li><a href="ContextCompat.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
